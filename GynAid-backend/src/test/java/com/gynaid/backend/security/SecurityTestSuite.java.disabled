package com.gynaid.backend.security;

import com.gynaid.backend.entity.User;
import com.gynaid.backend.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collection;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Comprehensive security test suite for authentication and authorization
 * Tests JWT security, password security, role-based access, and vulnerability protections
 */
@ExtendWith(MockitoExtension.class)
class SecurityTestSuite {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @InjectMocks
    private com.gynaid.backend.security.CustomUserDetailsService userDetailsService;

    private User testUser;
    private User adminUser;
    private User providerUser;

    @BeforeEach
    void setUp() {
        // Setup test users with different roles
        testUser = User.builder()
            .id(1L)
            .email("client@example.com")
            .password("hashedPassword123!")
            .firstName("Jane")
            .lastName("Client")
            .phoneNumber("+256700123456")
            .role(User.UserRole.CLIENT)
            .status(User.UserStatus.ACTIVE)
            .profileCompletionStatus(User.ProfileCompletionStatus.BASIC_COMPLETE)
            .createdAt(LocalDateTime.now().minusDays(30))
            .lastLoginAt(LocalDateTime.now().minusHours(2))
            .failedLoginAttempts(0)
            .accountLockedUntil(null)
            .build();

        adminUser = User.builder()
            .id(2L)
            .email("admin@gyna-id.com")
            .password("hashedPassword456!")
            .firstName("System")
            .lastName("Administrator")
            .phoneNumber("+256700123457")
            .role(User.UserRole.ADMIN)
            .status(User.UserStatus.ACTIVE)
            .profileCompletionStatus(User.ProfileCompletionStatus.BASIC_COMPLETE)
            .createdAt(LocalDateTime.now().minusDays(365))
            .lastLoginAt(LocalDateTime.now().minusMinutes(30))
            .failedLoginAttempts(0)
            .accountLockedUntil(null)
            .build();

        providerUser = User.builder()
            .id(3L)
            .email("provider@example.com")
            .password("hashedPassword789!")
            .firstName("Dr.")
            .lastName("Smith")
            .phoneNumber("+256700123458")
            .role(User.UserRole.PROVIDER_INDIVIDUAL)
            .status(User.UserStatus.ACTIVE)
            .profileCompletionStatus(User.ProfileCompletionStatus.BASIC_COMPLETE)
            .createdAt(LocalDateTime.now().minusDays(180))
            .lastLoginAt(LocalDateTime.now().minusHours(1))
            .failedLoginAttempts(0)
            .accountLockedUntil(null)
            .build();
    }

    @Test
    void testUserDetailsServiceLoadUserByUsernameSuccess() {
        // Arrange
        when(userRepository.findByEmail("client@example.com")).thenReturn(Optional.of(testUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("client@example.com");

        // Assert
        assertNotNull(userDetails);
        assertEquals("client@example.com", userDetails.getUsername());
        assertEquals("hashedPassword123!", userDetails.getPassword());
        assertTrue(userDetails.isAccountNonExpired());
        assertTrue(userDetails.isAccountNonLocked());
        assertTrue(userDetails.isCredentialsNonExpired());
        assertTrue(userDetails.isEnabled());
        
        // Check authorities
        Collection<?> authorities = userDetails.getAuthorities();
        assertEquals(1, authorities.size());
        assertTrue(authorities.stream()
            .anyMatch(auth -> auth.toString().equals("ROLE_CLIENT")));
    }

    @Test
    void testUserDetailsServiceLoadUserByUsernameNotFound() {
        // Arrange
        when(userRepository.findByEmail("nonexistent@example.com")).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(UsernameNotFoundException.class, () -> {
            userDetailsService.loadUserByUsername("nonexistent@example.com");
        });
    }

    @Test
    void testUserDetailsServiceForAdminUser() {
        // Arrange
        when(userRepository.findByEmail("admin@gyna-id.com")).thenReturn(Optional.of(adminUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("admin@gyna-id.com");

        // Assert
        assertNotNull(userDetails);
        assertEquals("admin@gyna-id.com", userDetails.getUsername());
        assertTrue(userDetails.isAccountNonExpired());
        assertTrue(userDetails.isAccountNonLocked());
        assertTrue(userDetails.isCredentialsNonExpired());
        assertTrue(userDetails.isEnabled());
        
        // Check admin authorities
        Collection<?> authorities = userDetails.getAuthorities();
        assertEquals(1, authorities.size());
        assertTrue(authorities.stream()
            .anyMatch(auth -> auth.toString().equals("ROLE_ADMIN")));
    }

    @Test
    void testUserDetailsServiceForProviderUser() {
        // Arrange
        when(userRepository.findByEmail("provider@example.com")).thenReturn(Optional.of(providerUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("provider@example.com");

        // Assert
        assertNotNull(userDetails);
        assertEquals("provider@example.com", userDetails.getUsername());
        
        // Check provider authorities
        Collection<?> authorities = userDetails.getAuthorities();
        assertEquals(1, authorities.size());
        assertTrue(authorities.stream()
            .anyMatch(auth -> auth.toString().equals("ROLE_PROVIDER_INDIVIDUAL")));
    }

    @Test
    void testLockedAccountHandling() {
        // Arrange - User with locked account
        User lockedUser = User.builder()
            .id(4L)
            .email("locked@example.com")
            .password("hashedPassword!")
            .firstName("Locked")
            .lastName("User")
            .role(User.UserRole.CLIENT)
            .status(User.UserStatus.ACTIVE)
            .failedLoginAttempts(5)
            .accountLockedUntil(LocalDateTime.now().plusMinutes(30)) // Locked for 30 more minutes
            .build();

        when(userRepository.findByEmail("locked@example.com")).thenReturn(Optional.of(lockedUser));

        // Act & Assert - Should throw LockedException
        assertThrows(org.springframework.security.authentication.LockedException.class, () -> {
            userDetailsService.loadUserByUsername("locked@example.com");
        });
    }

    @Test
    void testInactiveAccountHandling() {
        // Arrange - User with inactive status
        User inactiveUser = User.builder()
            .id(5L)
            .email("inactive@example.com")
            .password("hashedPassword!")
            .firstName("Inactive")
            .lastName("User")
            .role(User.UserRole.CLIENT)
            .status(User.UserStatus.INACTIVE)
            .build();

        when(userRepository.findByEmail("inactive@example.com")).thenReturn(Optional.of(inactiveUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("inactive@example.com");

        // Assert - Account should be disabled
        assertNotNull(userDetails);
        assertFalse(userDetails.isEnabled());
    }

    @Test
    void testSuspendedAccountHandling() {
        // Arrange - User with suspended status
        User suspendedUser = User.builder()
            .id(6L)
            .email("suspended@example.com")
            .password("hashedPassword!")
            .firstName("Suspended")
            .lastName("User")
            .role(User.UserRole.CLIENT)
            .status(User.UserStatus.SUSPENDED)
            .build();

        when(userRepository.findByEmail("suspended@example.com")).thenReturn(Optional.of(suspendedUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("suspended@example.com");

        // Assert - Account should be disabled
        assertNotNull(userDetails);
        assertFalse(userDetails.isEnabled());
    }

    @Test
    void testPasswordEncoder() {
        // Arrange
        String plainPassword = "SecurePassword123!";
        String hashedPassword = "hashedSecurePassword123!";

        when(passwordEncoder.encode(plainPassword)).thenReturn(hashedPassword);

        // Act
        String encodedPassword = passwordEncoder.encode(plainPassword);

        // Assert
        assertNotNull(encodedPassword);
        assertEquals(hashedPassword, encodedPassword);
    }

    @Test
    void testPasswordMatching() {
        // Arrange
        String plainPassword = "SecurePassword123!";
        String hashedPassword = "$2a$10$encryptedHashedPassword123";

        when(passwordEncoder.matches(plainPassword, hashedPassword)).thenReturn(true);
        when(passwordEncoder.matches("wrongPassword", hashedPassword)).thenReturn(false);

        // Act & Assert
        assertTrue(passwordEncoder.matches(plainPassword, hashedPassword));
        assertFalse(passwordEncoder.matches("wrongPassword", hashedPassword));
    }

    @Test
    void testSecurityVulnerabilities() {
        // Test SQL Injection protection through JPA
        // This tests that our repositories use parameterized queries

        // Arrange - Test with potentially malicious input
        String maliciousEmail = "'; DROP TABLE users; --@example.com";
        
        when(userRepository.findByEmail(maliciousEmail)).thenReturn(Optional.empty());

        // Act
        assertThrows(UsernameNotFoundException.class, () -> {
            userDetailsService.loadUserByUsername(maliciousEmail);
        });

        // Assert - Verify that the malicious input was handled safely
        // (In real implementation, this would involve checking database integrity)
        // For this test, we verify that no exception was thrown from the SQL layer
        verify(userRepository, times(1)).findByEmail(maliciousEmail);
    }

    @Test
    void testRoleHierarchyAndPermissions() {
        // Test that different roles have appropriate permissions

        // Admin should have ADMIN role
        when(userRepository.findByEmail("admin@gyna-id.com")).thenReturn(Optional.of(adminUser));
        UserDetails adminDetails = userDetailsService.loadUserByUsername("admin@gyna-id.com");
        assertTrue(adminDetails.getAuthorities().stream()
            .anyMatch(auth -> auth.toString().equals("ROLE_ADMIN")));

        // Provider should have PROVIDER role
        when(userRepository.findByEmail("provider@example.com")).thenReturn(Optional.of(providerUser));
        UserDetails providerDetails = userDetailsService.loadUserByUsername("provider@example.com");
        assertTrue(providerDetails.getAuthorities().stream()
            .anyMatch(auth -> auth.toString().equals("ROLE_PROVIDER_INDIVIDUAL")));

        // Client should have CLIENT role
        when(userRepository.findByEmail("client@example.com")).thenReturn(Optional.of(testUser));
        UserDetails clientDetails = userDetailsService.loadUserByUsername("client@example.com");
        assertTrue(clientDetails.getAuthorities().stream()
            .anyMatch(auth -> auth.toString().equals("ROLE_CLIENT")));
    }

    @Test
    void testSessionSecurity() {
        // Test session timeout and security properties

        // Act & Assert - All active accounts should have proper security flags
        when(userRepository.findByEmail("client@example.com")).thenReturn(Optional.of(testUser));
        UserDetails userDetails = userDetailsService.loadUserByUsername("client@example.com");

        assertTrue(userDetails.isAccountNonExpired(), "Active account should not be expired");
        assertTrue(userDetails.isAccountNonLocked(), "Active account should not be locked");
        assertTrue(userDetails.isCredentialsNonExpired(), "Active account credentials should not be expired");
        assertTrue(userDetails.isEnabled(), "Active account should be enabled");
    }

    @Test
    void testDataValidationAndSanitization() {
        // Test that user data is properly validated

        // Arrange
        String validEmail = "user@example.com";
        String invalidEmails = Arrays.asList(
            null,
            "",
            "invalid-email",
            "user@",
            "@domain.com",
            "user..double.dot@example.com",
            "user@domain",
            "user@domain.c"
        ).toArray(new String[0]);

        when(userRepository.findByEmail(validEmail)).thenReturn(Optional.of(testUser));

        // Test valid email
        assertDoesNotThrow(() -> {
            userDetailsService.loadUserByUsername(validEmail);
        });

        // Test invalid emails (should be handled by validation layer)
        for (String invalidEmail : invalidEmails) {
            assertThrows(Exception.class, () -> {
                userDetailsService.loadUserByUsername(invalidEmail);
            });
        }
    }

    @Test
    void testAccountAgeAndSecurity() {
        // Test security based on account age and last login

        // Fresh account (created recently)
        User freshUser = User.builder()
            .id(7L)
            .email("fresh@example.com")
            .password("hashedPassword!")
            .firstName("Fresh")
            .lastName("User")
            .role(User.UserRole.CLIENT)
            .status(User.UserStatus.ACTIVE)
            .createdAt(LocalDateTime.now().minusDays(1)) // Created yesterday
            .failedLoginAttempts(0)
            .accountLockedUntil(null)
            .build();

        when(userRepository.findByEmail("fresh@example.com")).thenReturn(Optional.of(freshUser));

        UserDetails freshUserDetails = userDetailsService.loadUserByUsername("fresh@example.com");
        assertTrue(freshUserDetails.isAccountNonExpired());
        assertTrue(freshUserDetails.isCredentialsNonExpired());

        // Old account (no recent login)
        User oldUser = User.builder()
            .id(8L)
            .email("old@example.com")
            .password("hashedPassword!")
            .firstName("Old")
            .lastName("User")
            .role(User.UserRole.CLIENT)
            .status(User.UserStatus.ACTIVE)
            .createdAt(LocalDateTime.now().minusDays(400)) // Very old account
            .lastLoginAt(LocalDateTime.now().minusDays(365)) // No login for a year
            .failedLoginAttempts(0)
            .accountLockedUntil(null)
            .build();

        when(userRepository.findByEmail("old@example.com")).thenReturn(Optional.of(oldUser));

        UserDetails oldUserDetails = userDetailsService.loadUserByUsername("old@example.com");
        // Account should still be valid but credentials might need review
        assertTrue(oldUserDetails.isAccountNonExpired());
    }
}